// $Id: mrdgen.c,v 1.6 2005/02/18 22:32:41 greg Exp $

#include <stdio.h>
#include <string.h>
#include <time.h>
#include "a.h"
#include "mrd.h"
#include "mrdgen.h"

static int gen_debug = 0;
static int debug = 0;

static void comment( char *name, FILE *fp )
{
  time_t t;
  fprintf( fp,
    "// Parser \'%s\' generated by mrdgen %s\n",
    name, asctime( localtime( &t ) ) );
}

static void preamble( char *name, FILE *fp )
{
  comment( name, fp );

  fprintf( fp, "#include <stdio.h>\n" );
  fprintf( fp, "#include <string.h>\n" );
  fprintf( fp, "#include \"a.h\"\n" );
  fprintf( fp, "#include \"mem.h\"\n" );
  fprintf( fp, "#define MRDGEN_DEBUG %d\n", debug );
  fprintf( fp, "#include \"mrdgenlib.h\"\n" );
  fprintf( fp, "#include \"%s.h\"\n", name );

  fprintf( fp, "static char *buf;\n" );
  fprintf( fp, "static int bufsize;\n" );
  fprintf( fp, "static dexp Ok;\n" );
  fprintf( fp, "static dexp Bad;\n" );
  fprintf( fp, "static dexp *memos=0;\n" );
  fprintf( fp, "static void init() {\n" );
  fprintf( fp, "  Ok = S(Ok);\n" );
  fprintf( fp, "  Bad = S(Bad);\n" );
  fprintf( fp, "}\n\n" );
}

static void postamble( dexp index, dexp grammar, dexp top,
  char *name, FILE *fp )
{
  int topnum = gI(gM(index,gM(grammar,top)));
  int maxnum = gI(gM(index,Nil));
  fprintf( fp, "dexp %s( char *abuf, int asize ) {\n", name );
  fprintf( fp, "  buf = abuf;\n" );
  fprintf( fp, "  bufsize = asize;\n" );
  fprintf( fp, "  memos = (dexp*)malik( (bufsize+1) * %d * sizeof(dexp*) );\n",
    maxnum );
  fprintf( fp, "  init();\n" );
  fprintf( fp, "  dexp raw = call( %d, 0 );\n", topnum );
  fprintf( fp, "  fri( memos );\n" );
  fprintf( fp, "  memos = 0;\n" );

  fprintf( fp, "  if (!strcmp(CONSCTORS(raw),\"Bad\")) {\n" );
  fprintf( fp, "    return raw;\n" );
  fprintf( fp, "  } else {\n" );
  fprintf( fp, "    int pos = gI(gK(raw,1));\n" );
  fprintf( fp, "    if (pos != bufsize) {\n" );
  fprintf( fp, "      return K(Bad,K(notatend,I(pos),I(bufsize)));\n" );
  fprintf( fp, "    } else {\n" );
  fprintf( fp, "      return K(Ok,gK(raw,0));\n" );
  fprintf( fp, "    }\n" );
  fprintf( fp, "  }\n" );

#if 0
  fprintf( fp, "  CASE (raw) {\n" );
  fprintf( fp, "    match (K(Bad,_(why))) {\n" );
  fprintf( fp, "      return raw;\n" );
  fprintf( fp, "    } else match (K(Ok,_(tree),_(pos))) {\n" );
  fprintf( fp, "      int pos = gI(V(pos));\n" );
  fprintf( fp, "      if (pos != bufsize) {\n" );
  fprintf( fp, "        return K(Bad,K(notatend,I(pos),I(bufsize)));\n" );
  fprintf( fp, "      } else {\n" );
  fprintf( fp, "        return K(Ok,V(tree));\n" );
  fprintf( fp, "      }\n" );
  fprintf( fp, "    }\n" );
  fprintf( fp, "  } ENDCASE;\n" );
#endif
  fprintf( fp, "  A(0);\n" );
  fprintf( fp, "  return Nil;\n" );
  fprintf( fp, "}\n" );

  fprintf( fp, "\n" );

  fprintf( fp, "dexp %s_file( char *filename ) {\n", name );
  fprintf( fp, "  return mrdgen_parse_from_file( &%s, filename );\n", name );
  fprintf( fp, "}\n" );
}

static int mrdgen_exp( dexp done, dexp index, dexp grammar,
  dexp exp, FILE *fp )
{
  dexp dexpnum = gM(index,exp);
  int expnum = gI(dexpnum);
  if (gM(done,dexpnum)) {
    return expnum;
  }
  pM(done,dexpnum,I(1));

  if (gen_debug) {
    printf( "-- %d --\n", expnum );
    dspew( exp );
  }

  CASE (exp) {
    match (K(Or,_(a),_(b))) {
      dexp a = V(a);
      dexp b = V(b);
      int aexpnum = mrdgen_exp( done, index, grammar, a, fp );
      int bexpnum = mrdgen_exp( done, index, grammar, b, fp );
      fprintf( fp, "static dexp e_%d( int p ) {\n", expnum );
      fprintf( fp, "  dexp ans;\n" );
      fprintf( fp, "  ans = call( %d, p );\n", aexpnum );

      fprintf( fp, "if (!strcmp(CONSCTORS(ans),\"Ok\")) {\n" );
      fprintf( fp, "  return ans;\n" );
      fprintf( fp, "} else {\n" );
      fprintf( fp, "  return call( %d, p );\n", bexpnum );
      fprintf( fp, "}\n" );

#if 0
      fprintf( fp, "  CASE (ans) {\n" );
      fprintf( fp, "    match (K(Ok,_(tree),_(pos))) {\n" );
      fprintf( fp, "      return ans;\n" );
      fprintf( fp, "    } else match (K(Bad,_(why))) {\n" );
      fprintf( fp, "      return call( %d, p );\n", bexpnum );
      fprintf( fp, "    }\n" );
      fprintf( fp, "  } ENDCASE;\n" );
#endif

      fprintf( fp, "  A(0);\n" );
      fprintf( fp, "  return Nil;\n" );
      fprintf( fp, "}\n\n" );
    } else match (K(Seq,_(ctor),_(parts))) {
      int n = dexp_list_length( V(parts) );
      int i;
      dexp expnums = AR(n);
      for (i=0; i<n; ++i) {
        pA( expnums, i, I(mrdgen_exp( done, index, grammar, dexp_nth( V(parts), i ), fp )) );
      }
      fprintf( fp, "static dexp e_%d( int p ) {\n", expnum );
      fprintf( fp, "  int cp;\n" );
      fprintf( fp, "  dexp parts[%d];\n", n );
      fprintf( fp, "  dexp ans, sub;\n" );
      fprintf( fp, "  cp = p;\n" );
      for (i=0; i<n; ++i) {
        fprintf( fp, "  sub = call( %d, cp );\n", gI(gA(expnums,i)) );

      fprintf( fp, "  if (!strcmp(CONSCTORS(sub),\"Bad\")) {\n" );
      fprintf( fp, "    return sub;\n" );
      fprintf( fp, "  } else {\n" );
      fprintf( fp, "    parts[%d] = gK(sub,0);\n", i );
      fprintf( fp, "    cp = gI(gK(sub,1));\n" );
      fprintf( fp, "  }\n" );

#if 0
        fprintf( fp, "  CASE (sub) {\n" );
        fprintf( fp, "    match (K(Bad,_(why))) {\n" );
        fprintf( fp, "      return sub;\n" );
        fprintf( fp, "    } else match (K(Ok,_(tree),_(pos))) {\n" );
        fprintf( fp, "      parts[%d] = V(tree);\n", i );
        fprintf( fp, "      cp = gI(V(pos));\n" );
        fprintf( fp, "    }\n" );
        fprintf( fp, "  } ENDCASE;\n" );
#endif
      }
      fprintf( fp, "  ans = dexp_make_empty_cons( \"%s\", %d );\n",
        SYMSTRING(V(ctor)), n );
      for (i=0; i<n; ++i) {
        fprintf( fp, "  pK( ans, %d, parts[%d] );\n", i, i );
      }
      fprintf( fp, "  return K(Ok,ans,I(cp));\n" );
      fprintf( fp, "}\n\n" );
    } else match (K((..),_(c0),_(c1))) {
      int c0 = (int)gC(V(c0));
      int c1 = (int)gC(V(c1));
      fprintf( fp, "static dexp e_%d( int p ) {\n", expnum );
      fprintf( fp, "  int c = buf[p];\n" );
      fprintf( fp, "  if (p>=bufsize) {\n" );
      fprintf( fp, "    return K(Bad,S(ranout));\n" );
      fprintf( fp, "  }\n" );
      fprintf( fp, "  if (c>=%d && c<=%d) {\n", c0, c1 );
      fprintf( fp, "    return K(Ok,K(Char,mkchar( buf[p] )),I(p+1));\n" );
      fprintf( fp, "  } else {\n" );
      fprintf( fp, "    return K(Bad,Nil);\n" );
      fprintf( fp, "  }\n" );
      fprintf( fp, "}\n\n" );
    } else match (K(NT,_(nt))) {
      int ntnum = gI(gM(index,gM(grammar,V(nt))));
      fprintf( fp, "static dexp e_%d( int p ) {\n", expnum );
      fprintf( fp, "  return call( %d, p );\n", ntnum );
      fprintf( fp, "}\n\n" );
    } else match (K(Nothing,_(sym))) {
      fprintf( fp, "static dexp e_%d( int p ) {\n", expnum );
      fprintf( fp, "  return K(Ok,S(%s),I(p));\n", SYMSTRING(V(sym)) );
      fprintf( fp, "}\n\n" );
    } else match (K(String,_(s))) {
      char *s = gST(V(s));
      char *escaped_s = gST(dexp_escape(V(s)));
      int len = strlen( s );
      fprintf( fp, "static dexp e_%d( int p ) {\n", expnum );
      fprintf( fp, "  if (p+%d>=bufsize) {\n", len );
      fprintf( fp, "    return K(Bad,S(ranout));\n" );
      fprintf( fp, "  }\n" );
      fprintf( fp, "  if (!strncmp( buf+p, \"%s\", %d )) {\n",
        escaped_s, len );
      fprintf( fp, "    return K(Ok,K(String,mkstring(\"%s\")),I(p+%d));\n",
        escaped_s, len );
      fprintf( fp, "  } else {\n" );
      fprintf( fp, "    return K(Bad,Nil);\n" );
      fprintf( fp, "  }\n" );
      fprintf( fp, "}\n\n" );
    }
  } ENDCASE;

  return expnum;
}

static int iserial=0;
void make_index_exp( dexp map, dexp grammar, dexp exp )
{
  dexp di = gM(map,exp);
  if (di==0) {
    di = I(iserial++);
    pM(map,exp,di);
  } else {
    return;
  }

  CASE (exp) {
    match (K(Or,_(a),_(b))) {
      make_index_exp( map, grammar, V(a) );
      make_index_exp( map, grammar, V(b) );
    } else match (K(Seq,_(ctor),_(parts))) {
      FORLIST(V(parts),e) {
        make_index_exp( map, grammar, e );
      }
    } else match (K(NT,_(nt))) {
      dexp exp = gM(grammar,V(nt));
      if (!exp) {
        err(( "Can't find NT '%s' in grammar.\n", SYMSTRING(V(nt)) ));
      }
      make_index_exp( map, grammar, exp );
    } otherwise (t) {}
  } ENDCASE;
}

// Map expressions to integers
static dexp make_index( dexp grammar )
{
  dexp m = EMAP();
  FORMAP (grammar,term,expansion) {
    make_index_exp( m, grammar, expansion );
  }
  // Add terminator -- the index of this is thus one greater
  // than the greatest actual index.
  make_index_exp( m, grammar, Nil );
  return m;
}

static void declare( dexp index, FILE *fp )
{
  int maxnum = gI(gM(index,Nil));
  FORMAP (index,exp,n) {
    if (gI(n) != maxnum) {
      fprintf( fp, "static dexp e_%d( int p );\n", gI(n) );
    }
  }
}

static dexp mrdgen_grammar( dexp index, dexp grammar, FILE *fp )
{
  dexp done = EMAP();

  declare( index, fp );

  fprintf( fp, "\n" );

  FORMAP (grammar, term, expansion) {
    mrdgen_exp( done, index, grammar, expansion, fp );
  }

  return index;
}

static void mrdgen_s( dexp grammar, dexp top, char *name, FILE *fp )
{
  dexp index;

  index = make_index( grammar );

  preamble( name, fp );
  index = mrdgen_grammar( index, grammar, fp );
  postamble( index, grammar, top, name, fp );
}

static void mrdgen_header( char *name, FILE *fp )
{
  comment( name, fp );

  fprintf( fp, "#include \"dexp.h\"\n" );
  fprintf( fp, "dexp %s( char *abuf, int asize );\n", name );
  fprintf( fp, "dexp %s_file( char *filename );\n", name );
}

#define BUFSIZE 64
void mrdgen( dexp grammar, dexp top, char *name )
{
  static char buf[BUFSIZE];

  int n = snprintf( buf, BUFSIZE, "%s.c", name );
  A(n<BUFSIZE);

  FILE *fp = fopen( buf, "w" );
  A(fp);

  mrdgen_s( grammar, top, name, fp );

  fclose( fp );

  n = snprintf( buf, BUFSIZE, "%s.h", name );
  A(n<BUFSIZE);

  fp = fopen( buf, "w" );
  A(fp);

  mrdgen_header( name, fp );

  fclose( fp );
}
